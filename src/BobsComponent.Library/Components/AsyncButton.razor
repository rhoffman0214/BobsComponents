@using System.Threading
@using BobsComponent.Library.Enums
@using BobsComponent.Library.Models
@using BobsComponent.Library.Models.Events
@using BobsComponent.Library.Utilities
@using Microsoft.AspNetCore.Components
@using Microsoft.Extensions.Logging
@namespace BobsComponent.Library.Components
@inject ILogger<AsyncButton>? Logger

@if (IsButtonDisabled)
{
    <button type="@ButtonType"
            id="@Id"
            name="@Name"
            class="async-button btn-@Style.ToString().ToLower() btn-@Size.ToString().ToLower() state-@State.ToString().ToLower() @(FullWidth ? "full-width" : "") @CssClass"
            title="@Title"
            tabindex="@TabIndex"
            form="@Form"
            aria-label="@AriaLabel"
            aria-describedby="@AriaDescribedBy"
            aria-busy="@(State == LoadingState.Loading ? "true" : "false")"
            aria-disabled="true"
            disabled
            @onclick="HandleClick"
            @attributes="AdditionalAttributes">
        @ButtonContent
    </button>
}
else
{
    <button type="@ButtonType"
            id="@Id"
            name="@Name"
            class="async-button btn-@Style.ToString().ToLower() btn-@Size.ToString().ToLower() state-@State.ToString().ToLower() @(FullWidth ? "full-width" : "") @CssClass"
            title="@Title"
            tabindex="@TabIndex"
            form="@Form"
            aria-label="@AriaLabel"
            aria-describedby="@AriaDescribedBy"
            aria-busy="@(State == LoadingState.Loading ? "true" : "false")"
            @onclick="HandleClick"
            @attributes="AdditionalAttributes">
        @ButtonContent
    </button>
}

@if (State == LoadingState.Error && _currentError != null)
{
    <div class="error-message-container">
        <div class="error-message">
            <span class="error-icon">⚠️</span>
            <span class="error-text">@_currentError.Message</span>
        </div>
        @if (!string.IsNullOrWhiteSpace(_currentError.SuggestedAction))
        {
            <div class="error-suggestion">
                @((MarkupString)FormatSuggestedAction(_currentError.SuggestedAction))
            </div>
        }
        @if (ShowErrorRetry)
        {
            <button type="button" class="retry-button" @onclick="HandleRetry">
                ↻ Retry
            </button>
        }
    </div>
}

@if (ShowProgress && Progress > 0 && State == LoadingState.Loading)
{
    <ProgressBar Percentage="@Progress"
                 ColorVariant="ProgressBar.ProgressColorVariant.Primary"
                 ShowPercentage="false"
                 Animated="true" />
}

@code {
    /// <summary>
    /// Button text
    /// </summary>
    [Parameter]
    public string Text { get; set; } = "Click me";

    /// <summary>
    /// Text to show when loading
    /// </summary>
    [Parameter]
    public string? LoadingText { get; set; }

    /// <summary>
    /// Text to show on success
    /// </summary>
    [Parameter]
    public string? SuccessText { get; set; }

    /// <summary>
    /// Text to show on error
    /// </summary>
    [Parameter]
    public string? ErrorText { get; set; }

    /// <summary>
    /// Button style variant
    /// </summary>
    [Parameter]
    public ButtonStyle Style { get; set; } = ButtonStyle.Primary;

    /// <summary>
    /// Current loading state
    /// </summary>
    [Parameter]
    public LoadingState State { get; set; } = LoadingState.Idle;

    /// <summary>
    /// Progress percentage (0-100) if tracking progress
    /// </summary>
    [Parameter]
    public int Progress { get; set; } = 0;

    /// <summary>
    /// Show progress bar below button
    /// </summary>
    [Parameter]
    public bool ShowProgress { get; set; } = false;

    /// <summary>
    /// Show retry button on error
    /// </summary>
    [Parameter]
    public bool ShowErrorRetry { get; set; } = true;

    /// <summary>
    /// Button is disabled
    /// </summary>
    [Parameter]
    public bool IsDisabled { get; set; } = false;

    /// <summary>
    /// Button takes full width of container
    /// </summary>
    [Parameter]
    public bool FullWidth { get; set; } = false;

    /// <summary>
    /// Additional CSS classes
    /// </summary>
    [Parameter]
    public string? CssClass { get; set; }

    /// <summary>
    /// Button size variant
    /// </summary>
    [Parameter]
    public ButtonSize Size { get; set; } = ButtonSize.Medium;

    /// <summary>
    /// HTML button type attribute (button, submit, reset)
    /// </summary>
    [Parameter]
    public string ButtonType { get; set; } = "button";

    /// <summary>
    /// HTML id attribute
    /// </summary>
    [Parameter]
    public string? Id { get; set; }

    /// <summary>
    /// HTML name attribute (useful for forms)
    /// </summary>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// HTML title attribute (tooltip text)
    /// </summary>
    [Parameter]
    public string? Title { get; set; }

    /// <summary>
    /// HTML tabindex attribute (keyboard navigation order)
    /// </summary>
    [Parameter]
    public int? TabIndex { get; set; }

    /// <summary>
    /// HTML form attribute (associates button with a form)
    /// </summary>
    [Parameter]
    public string? Form { get; set; }

    /// <summary>
    /// ARIA label for screen readers
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }

    /// <summary>
    /// ARIA describedby attribute (references element IDs that describe this button)
    /// </summary>
    [Parameter]
    public string? AriaDescribedBy { get; set; }

    /// <summary>
    /// Icon to display in the button (prefix or suffix based on IconPosition)
    /// </summary>
    [Parameter]
    public RenderFragment? Icon { get; set; }

    /// <summary>
    /// Position of the icon relative to text
    /// </summary>
    [Parameter]
    public IconPosition IconPosition { get; set; } = IconPosition.Left;

    /// <summary>
    /// Child content (alternative to Text parameter)
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Captures all additional HTML attributes not explicitly defined
    /// Allows passing any HTML attribute like data-*, aria-*, etc.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Synchronous click event (fires before OnClickAsync)
    /// </summary>
    [Parameter]
    public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Async operation to execute when clicked (receives CancellationToken)
    /// BREAKING CHANGE: Signature changed from Func&lt;Task&gt; to Func&lt;CancellationToken, Task&gt;
    /// </summary>
    [Parameter]
    public Func<CancellationToken, Task>? OnClickAsync { get; set; }

    /// <summary>
    /// Event triggered before async operation starts (can cancel by setting CanCancel = false)
    /// </summary>
    [Parameter]
    public EventCallback<AsyncButtonEventArgs> OnBeforeClick { get; set; }

    /// <summary>
    /// Event triggered when async operation completes successfully
    /// </summary>
    [Parameter]
    public EventCallback<AsyncSuccessEventArgs> OnSuccess { get; set; }

    /// <summary>
    /// Event triggered when async operation fails with an error
    /// </summary>
    [Parameter]
    public EventCallback<ComponentErrorEventArgs> OnError { get; set; }

    /// <summary>
    /// Event triggered when async operation is about to be retried after failure
    /// </summary>
    [Parameter]
    public EventCallback<AsyncRetryEventArgs> OnRetry { get; set; }

    /// <summary>
    /// Event triggered when async operation is cancelled
    /// </summary>
    [Parameter]
    public EventCallback OnCancel { get; set; }

    /// <summary>
    /// Configuration for automatic retry behavior with exponential backoff
    /// </summary>
    [Parameter]
    public RetryConfiguration? RetryConfig { get; set; }

    /// <summary>
    /// Event triggered when state changes
    /// </summary>
    [Parameter]
    public EventCallback<LoadingState> OnStateChanged { get; set; }

    /// <summary>
    /// Event triggered when progress updates
    /// </summary>
    [Parameter]
    public EventCallback<int> OnProgressChanged { get; set; }

    /// <summary>
    /// Auto-reset to idle after success (milliseconds, 0 to disable)
    /// </summary>
    [Parameter]
    public int AutoResetDelay { get; set; } = 2000;

    private CancellationTokenSource? _cancellationTokenSource;

    // Error tracking
    private ComponentError? _currentError;
    private readonly List<ComponentError> _errorHistory = new();
    private readonly ErrorMetadata _errorMetadata = new();

    // Operation tracking
    private OperationMetadata? _currentOperation;
    private readonly List<OperationMetadata> _operationHistory = new();

    // Retry tracking
    private int _retryCount = 0;

    private async Task HandleClick(MouseEventArgs args)
    {
        // 1. Fire synchronous OnClick event first
        if (OnClick.HasDelegate)
        {
            await OnClick.InvokeAsync(args);
        }

        // 2. Check if async operation defined
        if (OnClickAsync == null)
            return;

        // 3. Prevent double-execution
        if (State == LoadingState.Loading)
        {
            Logger?.LogWarning("Button clicked while operation in progress (OperationId: {OperationId})", _currentOperation?.OperationId ?? "unknown");
            return;
        }

        // 4. Create operation metadata
        var operationId = Guid.NewGuid().ToString("N")[..8];
        var operation = new OperationMetadata { OperationId = operationId };
        _currentOperation = operation;

        Logger?.LogDebug("Starting async operation (OperationId: {OperationId})", operationId);

        // 5. Fire OnBeforeClick (allows cancellation)
        if (OnBeforeClick.HasDelegate)
        {
            var beforeArgs = new AsyncButtonEventArgs
            {
                OperationId = operationId,
                Timestamp = DateTime.UtcNow,
                CanCancel = true,
                CancellationToken = default
            };

            await OnBeforeClick.InvokeAsync(beforeArgs);

            if (!beforeArgs.CanCancel)
            {
                Logger?.LogInformation("Operation cancelled by OnBeforeClick handler (OperationId: {OperationId})", operationId);
                return;
            }
        }

        // 6. Set loading state
        await SetStateAsync(LoadingState.Loading);
        _cancellationTokenSource = new CancellationTokenSource();
        var ct = _cancellationTokenSource.Token;

        // 7. Execute with retry logic
        var config = RetryConfig ?? new RetryConfiguration { Enabled = false, MaxAttempts = 1 };
        var maxAttempts = config.Enabled ? config.MaxAttempts : 1;

        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            operation.AttemptCount = attempt;

            try
            {
                Logger?.LogDebug("Executing operation attempt {Attempt}/{MaxAttempts} (OperationId: {OperationId})",
                    attempt, maxAttempts, operationId);

                await OnClickAsync(ct);

                // SUCCESS PATH
                operation.Success = true;
                operation.EndTime = DateTime.UtcNow;
                operation.FinalState = LoadingState.Success;
                _errorMetadata.RecordSuccess();
                _retryCount = 0;

                await SetStateAsync(LoadingState.Success);

                // Fire OnSuccess
                if (OnSuccess.HasDelegate)
                {
                    var successArgs = new AsyncSuccessEventArgs
                    {
                        OperationId = operationId,
                        Timestamp = DateTime.UtcNow,
                        Duration = operation.Duration,
                        AttemptNumber = attempt,
                        CancellationToken = ct
                    };

                    try
                    {
                        await OnSuccess.InvokeAsync(successArgs);
                    }
                    catch (Exception handlerEx)
                    {
                        Logger?.LogError(handlerEx, "OnSuccess handler threw exception (OperationId: {OperationId})", operationId);
                    }
                }

                Logger?.LogInformation("Operation succeeded in {Duration}ms (OperationId: {OperationId}, Attempts: {Attempts})",
                    operation.Duration.TotalMilliseconds, operationId, attempt);

                // Auto-reset
                if (AutoResetDelay > 0)
                {
                    await Task.Delay(AutoResetDelay, ct);
                    await SetStateAsync(LoadingState.Idle);
                }

                break; // Success - exit retry loop
            }
            catch (OperationCanceledException)
            {
                // CANCELLATION PATH
                operation.EndTime = DateTime.UtcNow;
                operation.FinalState = LoadingState.Error;
                await SetStateAsync(LoadingState.Error);

                if (OnCancel.HasDelegate)
                {
                    try
                    {
                        await OnCancel.InvokeAsync();
                    }
                    catch (Exception handlerEx)
                    {
                        Logger?.LogError(handlerEx, "OnCancel handler threw exception (OperationId: {OperationId})", operationId);
                    }
                }

                Logger?.LogWarning("Operation cancelled (OperationId: {OperationId})", operationId);
                break; // Don't retry cancellations
            }
            catch (Exception ex)
            {
                // ERROR PATH - GRACEFUL DEGRADATION
                var error = ComponentError.FromException(ex, "AsyncButton", operationId, context: new()
                {
                    ["ButtonText"] = Text,
                    ["ButtonId"] = Id ?? "unknown",
                    ["AttemptNumber"] = attempt,
                    ["MaxAttempts"] = maxAttempts
                });

                _currentError = error;
                _errorHistory.Add(error);
                _errorMetadata.RecordError(error);

                Logger?.LogError(ex, "Operation failed: {ErrorCode} - {DeveloperMessage} (OperationId: {OperationId}, Attempt: {Attempt}/{MaxAttempts})",
                    error.ErrorCode, LoggingHelpers.SanitizeMessage(error.DeveloperMessage ?? ""), operationId, attempt, maxAttempts);

                // Check if should retry
                var shouldRetryBasedOnConfig = config.ShouldRetry?.Invoke(ex) ?? error.IsRecoverable;
                var shouldRetry = attempt < maxAttempts && shouldRetryBasedOnConfig;

                if (shouldRetry)
                {
                    // Fire OnRetry and wait with exponential backoff
                    _retryCount++;
                    await HandleRetryWithBackoffAsync(error, attempt, ct, operationId);
                    continue; // Try again
                }
                else
                {
                    // Final failure - set error state
                    operation.Error = error;
                    operation.EndTime = DateTime.UtcNow;
                    operation.FinalState = LoadingState.Error;
                    await SetStateAsync(LoadingState.Error);

                    // Fire OnError (wrapped in try-catch to prevent handler errors from crashing component)
                    try
                    {
                        if (OnError.HasDelegate)
                        {
                            var errorArgs = new ComponentErrorEventArgs
                            {
                                Error = error,
                                AttemptNumber = attempt,
                                OperationId = operationId,
                                Timestamp = DateTime.UtcNow,
                                CancellationToken = ct,
                                WillRetry = false
                            };

                            await OnError.InvokeAsync(errorArgs);
                        }
                    }
                    catch (Exception handlerEx)
                    {
                        // OnError handler threw - log but don't crash component
                        Logger?.LogError(handlerEx, "OnError handler threw exception (OperationId: {OperationId})", operationId);
                    }

                    break; // Exit retry loop
                }
            }
            finally
            {
                if (attempt == maxAttempts || operation.Success || ct.IsCancellationRequested)
                {
                    _cancellationTokenSource?.Dispose();
                    _cancellationTokenSource = null;
                }
            }
        }

        // 8. Record operation history
        _operationHistory.Add(operation);
        _currentOperation = null;

        Logger?.LogDebug("Operation completed: {Summary}", operation.GetSummary());
    }

    private async Task HandleRetry()
    {
        await SetStateAsync(LoadingState.Idle);
        await HandleClick(new Microsoft.AspNetCore.Components.Web.MouseEventArgs());
    }

    private async Task HandleRetryWithBackoffAsync(ComponentError error, int attempt, CancellationToken ct, string operationId)
    {
        var config = RetryConfig ?? new RetryConfiguration();
        var delay = CalculateBackoffDelay(config.InitialDelay, attempt, config.BackoffMultiplier, config.MaxDelay);

        // Fire OnRetry event
        if (OnRetry.HasDelegate)
        {
            var retryArgs = new AsyncRetryEventArgs
            {
                AttemptNumber = attempt,
                LastError = error,
                BackoffDelay = delay,
                OperationId = operationId,
                Timestamp = DateTime.UtcNow,
                CancellationToken = ct
            };

            try
            {
                await OnRetry.InvokeAsync(retryArgs);
            }
            catch (Exception handlerEx)
            {
                Logger?.LogError(handlerEx, "OnRetry handler threw exception (OperationId: {OperationId})", operationId);
            }
        }

        Logger?.LogWarning("Retrying after {Delay}ms (OperationId: {OperationId}, Attempt: {Attempt})",
            delay.TotalMilliseconds, operationId, attempt);

        await Task.Delay(delay, ct);
    }

    private static TimeSpan CalculateBackoffDelay(TimeSpan initial, int attempt, double multiplier, TimeSpan max)
    {
        var delay = initial.TotalMilliseconds * Math.Pow(multiplier, attempt - 1);
        return TimeSpan.FromMilliseconds(Math.Min(delay, max.TotalMilliseconds));
    }

    private async Task SetStateAsync(LoadingState newState)
    {
        State = newState;
        await OnStateChanged.InvokeAsync(State);
        StateHasChanged();
    }

    /// <summary>
    /// Updates the progress percentage
    /// </summary>
    public async Task UpdateProgressAsync(int progress)
    {
        Progress = Math.Clamp(progress, 0, 100);
        await OnProgressChanged.InvokeAsync(Progress);
        StateHasChanged();
    }

    /// <summary>
    /// Cancels the current operation
    /// </summary>
    public void Cancel()
    {
        _cancellationTokenSource?.Cancel();
    }

    /// <summary>
    /// Resets the button to idle state
    /// </summary>
    public async Task ResetAsync()
    {
        await SetStateAsync(LoadingState.Idle);
        Progress = 0;
    }

    /// <summary>
    /// Programmatically triggers the button click
    /// </summary>
    public async Task TriggerClickAsync()
    {
        await HandleClick(new Microsoft.AspNetCore.Components.Web.MouseEventArgs());
    }

    /// <summary>
    /// Computed property for button disabled state
    /// </summary>
    private bool IsButtonDisabled => IsDisabled || State == LoadingState.Loading;

    /// <summary>
    /// Renders the button content based on current state
    /// </summary>
    private RenderFragment ButtonContent => builder =>
    {
        if (State == LoadingState.Loading)
        {
            builder.OpenComponent<LoadingSpinner>(0);
            builder.AddAttribute(1, "Style", LoadingSpinner.SpinnerStyle.Circle);
            builder.AddAttribute(2, "Size", LoadingSpinner.SpinnerSize.Small);
            builder.CloseComponent();

            builder.OpenElement(3, "span");
            builder.AddAttribute(4, "class", "button-text");
            builder.AddContent(5, LoadingText ?? Text);
            builder.CloseElement();
        }
        else if (State == LoadingState.Success)
        {
            builder.OpenElement(6, "span");
            builder.AddAttribute(7, "class", "success-icon");
            builder.AddContent(8, "✓");
            builder.CloseElement();

            builder.OpenElement(9, "span");
            builder.AddAttribute(10, "class", "button-text");
            builder.AddContent(11, SuccessText ?? "Success");
            builder.CloseElement();
        }
        else if (State == LoadingState.Error)
        {
            builder.OpenElement(12, "span");
            builder.AddAttribute(13, "class", "error-icon");
            builder.AddContent(14, "✕");
            builder.CloseElement();

            builder.OpenElement(15, "span");
            builder.AddAttribute(16, "class", "button-text");
            builder.AddContent(17, ErrorText ?? "Error");
            builder.CloseElement();
        }
        else
        {
            if (ChildContent != null)
            {
                builder.AddContent(18, ChildContent);
            }
            else
            {
                // Render icon on left if specified
                if (Icon != null && IconPosition == IconPosition.Left)
                {
                    builder.OpenElement(19, "span");
                    builder.AddAttribute(20, "class", "button-icon icon-left");
                    builder.AddContent(21, Icon);
                    builder.CloseElement();
                }

                // Render text
                builder.OpenElement(22, "span");
                builder.AddAttribute(23, "class", "button-text");
                builder.AddContent(24, Text);
                builder.CloseElement();

                // Render icon on right if specified
                if (Icon != null && IconPosition == IconPosition.Right)
                {
                    builder.OpenElement(25, "span");
                    builder.AddAttribute(26, "class", "button-icon icon-right");
                    builder.AddContent(27, Icon);
                    builder.CloseElement();
                }
            }
        }
    };

    /// <summary>
    /// Formats the suggested action text to include clickable links
    /// SECURITY: Validates and sanitizes URLs to prevent XSS attacks
    /// </summary>
    private string FormatSuggestedAction(string suggestedAction)
    {
        if (string.IsNullOrWhiteSpace(suggestedAction))
            return string.Empty;

        // Pattern to match "Learn more: <url>" at the end of the string
        var pattern = @"Learn more:\s*([\S]+)";
        var match = System.Text.RegularExpressions.Regex.Match(suggestedAction, pattern);

        if (!match.Success)
        {
            // No URL found, return HTML-encoded text
            return System.Net.WebUtility.HtmlEncode(suggestedAction);
        }

        var url = match.Groups[1].Value;

        // SECURITY: Validate URL to prevent XSS (javascript:, data:, etc.)
        if (!IsValidUrl(url))
        {
            // Invalid URL - return text without link
            return System.Net.WebUtility.HtmlEncode(suggestedAction.Replace(url, "[invalid URL]"));
        }

        // Extract the text before "Learn more:"
        var textBefore = suggestedAction.Substring(0, match.Index);
        var encodedTextBefore = System.Net.WebUtility.HtmlEncode(textBefore);
        var encodedUrl = System.Net.WebUtility.HtmlEncode(url);

        return $"{encodedTextBefore}<span class='learn-more-label'>Learn more:</span> <a href='{encodedUrl}' class='error-reference-link'>{encodedUrl}</a>";
    }

    /// <summary>
    /// Validates that a URL is safe to use in an href attribute
    /// SECURITY: Prevents javascript:, data:, vbscript:, and other XSS vectors
    /// </summary>
    private static bool IsValidUrl(string url)
    {
        if (string.IsNullOrWhiteSpace(url))
            return false;

        url = url.Trim().ToLowerInvariant();

        // Allow relative paths starting with /
        if (url.StartsWith("/"))
            return true;

        // Allow http and https only
        if (url.StartsWith("http://") || url.StartsWith("https://"))
            return true;

        // Block all other protocols (javascript:, data:, vbscript:, etc.)
        return false;
    }

    public void Dispose()
    {
        _cancellationTokenSource?.Dispose();
    }
}
